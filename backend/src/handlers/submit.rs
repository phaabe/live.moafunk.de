use crate::{AppError, AppState, Result};
use axum::{
    extract::{Multipart, State},
    Json,
};
use image::GenericImageView;
use image::{codecs::jpeg::JpegEncoder, codecs::png::PngEncoder, ColorType, ImageEncoder};
use std::sync::Arc;

fn normalize_image_content_type(filename: &str, fallback: &str) -> String {
    let ext = std::path::Path::new(filename)
        .extension()
        .and_then(|e| e.to_str())
        .unwrap_or("")
        .to_ascii_lowercase();

    match ext.as_str() {
        "png" => "image/png".to_string(),
        "jpg" | "jpeg" => "image/jpeg".to_string(),
        _ => fallback.to_string(),
    }
}

fn crop_square_image_if_supported(filename: &str, data: &[u8]) -> Option<Vec<u8>> {
    let ext = std::path::Path::new(filename)
        .extension()
        .and_then(|e| e.to_str())
        .unwrap_or("")
        .to_ascii_lowercase();

    let format = match ext.as_str() {
        "png" => image::ImageFormat::Png,
        "jpg" | "jpeg" => image::ImageFormat::Jpeg,
        _ => return None,
    };

    let img = image::load_from_memory_with_format(data, format)
        .or_else(|_| image::load_from_memory(data))
        .ok()?;

    let (w, h) = img.dimensions();
    let side = w.min(h);
    if side == 0 {
        return None;
    }

    let x = (w - side) / 2;
    let y = (h - side) / 2;
    let cropped = img.crop_imm(x, y, side, side);

    let mut out = Vec::new();
    match ext.as_str() {
        "png" => {
            let rgba = cropped.to_rgba8();
            let encoder = PngEncoder::new(&mut out);
            encoder
                .write_image(
                    rgba.as_raw(),
                    rgba.width(),
                    rgba.height(),
                    ColorType::Rgba8.into(),
                )
                .ok()?;
            Some(out)
        }
        "jpg" | "jpeg" => {
            let rgb = cropped.to_rgb8();
            let encoder = JpegEncoder::new_with_quality(&mut out, 92);
            encoder
                .write_image(
                    rgb.as_raw(),
                    rgb.width(),
                    rgb.height(),
                    ColorType::Rgb8.into(),
                )
                .ok()?;
            Some(out)
        }
        _ => None,
    }
}

use crate::models::SubmitResponse;
use crate::storage;

pub async fn submit_form(
    State(state): State<Arc<AppState>>,
    mut multipart: Multipart,
) -> Result<Json<SubmitResponse>> {
    tracing::info!("Received form submission");

    let mut artist_name = String::new();
    let mut pronouns = String::new();
    let mut track1_name = String::new();
    let mut track2_name = String::new();
    let mut no_voice_message = false;
    let mut instagram: Option<String> = None;
    let mut soundcloud: Option<String> = None;
    let mut bandcamp: Option<String> = None;
    let mut spotify: Option<String> = None;
    let mut other_social: Option<String> = None;
    let mut upcoming_events: Option<String> = None;
    let mut mentions: Option<String> = None;

    // File data
    // - artist_pic_original: raw upload as provided by the user
    // - artist_pic_cropped: cropped+filtered (no overlay) generated by the frontend
    // - artist_pic_branded: cropped+filtered+overlay generated by the frontend
    let mut artist_pic_original: Option<(String, Vec<u8>, String)> = None;
    let mut artist_pic_cropped: Option<(String, Vec<u8>, String)> = None;
    let mut artist_pic_branded: Option<(String, Vec<u8>, String)> = None;
    let mut voice_message: Option<(String, Vec<u8>, String)> = None;
    let mut track1_file: Option<(String, Vec<u8>, String)> = None;
    let mut track2_file: Option<(String, Vec<u8>, String)> = None;

    let max_size = state.config.max_file_size_bytes();
    let max_total_size = state.config.max_upload_size_bytes();
    let mut total_file_bytes: u64 = 0;

    while let Some(field) = multipart.next_field().await.map_err(|e| {
        tracing::error!("Failed to read multipart field: {}", e);
        AppError::Validation(format!("Failed to read form field: {}", e))
    })? {
        let name = field.name().unwrap_or("").to_string();
        tracing::debug!("Processing field: {}", name);

        match name.as_str() {
            "artist-name" => {
                artist_name = field.text().await.map_err(|e| {
                    AppError::Validation(format!("Failed to read artist name: {}", e))
                })?;
            }
            "pronouns" => {
                pronouns = field
                    .text()
                    .await
                    .map_err(|e| AppError::Validation(format!("Failed to read pronouns: {}", e)))?;
            }
            "track1-name" => {
                track1_name = field.text().await.map_err(|e| {
                    AppError::Validation(format!("Failed to read track1 name: {}", e))
                })?;
            }
            "track2-name" => {
                track2_name = field.text().await.map_err(|e| {
                    AppError::Validation(format!("Failed to read track2 name: {}", e))
                })?;
            }
            "no-voice-message" => {
                let value = field.text().await.unwrap_or_default();
                no_voice_message = value == "on" || value == "true";
            }
            "instagram" => {
                instagram = Some(field.text().await.unwrap_or_default()).filter(|s| !s.is_empty())
            }
            "soundcloud" => {
                soundcloud = Some(field.text().await.unwrap_or_default()).filter(|s| !s.is_empty())
            }
            "bandcamp" => {
                bandcamp = Some(field.text().await.unwrap_or_default()).filter(|s| !s.is_empty())
            }
            "spotify" => {
                spotify = Some(field.text().await.unwrap_or_default()).filter(|s| !s.is_empty())
            }
            "other-social" => {
                other_social =
                    Some(field.text().await.unwrap_or_default()).filter(|s| !s.is_empty())
            }
            "upcoming-events" => {
                upcoming_events =
                    Some(field.text().await.unwrap_or_default()).filter(|s| !s.is_empty())
            }
            "mentions" => {
                mentions = Some(field.text().await.unwrap_or_default()).filter(|s| !s.is_empty())
            }
            "artist-pic" => {
                let filename = field.file_name().unwrap_or("image.jpg").to_string();
                let content_type = field.content_type().unwrap_or("image/jpeg").to_string();
                let data = field.bytes().await.map_err(|e| {
                    AppError::Validation(format!("Failed to read artist pic: {}", e))
                })?;

                if data.len() as u64 > max_size {
                    return Err(AppError::FileTooLarge(state.config.max_file_size_mb));
                }

                total_file_bytes = total_file_bytes.saturating_add(data.len() as u64);
                if total_file_bytes > max_total_size {
                    return Err(AppError::UploadTooLarge(state.config.max_upload_size_mb));
                }

                let normalized_content_type =
                    normalize_image_content_type(&filename, &content_type);

                // Keep the original bytes intact.
                artist_pic_original = Some((filename, data.to_vec(), normalized_content_type));
            }
            "artist-pic-cropped" => {
                let filename = field
                    .file_name()
                    .unwrap_or("artist_cropped.jpg")
                    .to_string();
                let content_type = field.content_type().unwrap_or("image/jpeg").to_string();
                let data = field.bytes().await.map_err(|e| {
                    AppError::Validation(format!("Failed to read cropped artist pic: {}", e))
                })?;

                if data.len() as u64 > max_size {
                    return Err(AppError::FileTooLarge(state.config.max_file_size_mb));
                }

                total_file_bytes = total_file_bytes.saturating_add(data.len() as u64);
                if total_file_bytes > max_total_size {
                    return Err(AppError::UploadTooLarge(state.config.max_upload_size_mb));
                }

                let normalized_content_type =
                    normalize_image_content_type(&filename, &content_type);
                artist_pic_cropped = Some((filename, data.to_vec(), normalized_content_type));
            }
            "artist-pic-branded" => {
                let filename = field
                    .file_name()
                    .unwrap_or("artist_branded.jpg")
                    .to_string();
                let content_type = field.content_type().unwrap_or("image/jpeg").to_string();
                let data = field.bytes().await.map_err(|e| {
                    AppError::Validation(format!("Failed to read branded artist pic: {}", e))
                })?;

                if data.len() as u64 > max_size {
                    return Err(AppError::FileTooLarge(state.config.max_file_size_mb));
                }

                total_file_bytes = total_file_bytes.saturating_add(data.len() as u64);
                if total_file_bytes > max_total_size {
                    return Err(AppError::UploadTooLarge(state.config.max_upload_size_mb));
                }

                let normalized_content_type =
                    normalize_image_content_type(&filename, &content_type);
                artist_pic_branded = Some((filename, data.to_vec(), normalized_content_type));
            }
            "voice-message" => {
                let filename = field.file_name().unwrap_or("").to_string();
                if !filename.is_empty() {
                    let content_type = field.content_type().unwrap_or("audio/mpeg").to_string();
                    let data = field.bytes().await.map_err(|e| {
                        AppError::Validation(format!("Failed to read voice message: {}", e))
                    })?;

                    if data.len() as u64 > max_size {
                        return Err(AppError::FileTooLarge(state.config.max_file_size_mb));
                    }

                    total_file_bytes = total_file_bytes.saturating_add(data.len() as u64);
                    if total_file_bytes > max_total_size {
                        return Err(AppError::UploadTooLarge(state.config.max_upload_size_mb));
                    }

                    if !data.is_empty() {
                        voice_message = Some((filename, data.to_vec(), content_type));
                    }
                }
            }
            "track1-file" => {
                let filename = field.file_name().unwrap_or("track1.mp3").to_string();
                let content_type = field.content_type().unwrap_or("audio/mpeg").to_string();
                let data = field
                    .bytes()
                    .await
                    .map_err(|e| AppError::Validation(format!("Failed to read track1: {}", e)))?;

                if data.len() as u64 > max_size {
                    return Err(AppError::FileTooLarge(state.config.max_file_size_mb));
                }

                total_file_bytes = total_file_bytes.saturating_add(data.len() as u64);
                if total_file_bytes > max_total_size {
                    return Err(AppError::UploadTooLarge(state.config.max_upload_size_mb));
                }

                track1_file = Some((filename, data.to_vec(), content_type));
            }
            "track2-file" => {
                let filename = field.file_name().unwrap_or("track2.mp3").to_string();
                let content_type = field.content_type().unwrap_or("audio/mpeg").to_string();
                let data = field
                    .bytes()
                    .await
                    .map_err(|e| AppError::Validation(format!("Failed to read track2: {}", e)))?;

                if data.len() as u64 > max_size {
                    return Err(AppError::FileTooLarge(state.config.max_file_size_mb));
                }

                total_file_bytes = total_file_bytes.saturating_add(data.len() as u64);
                if total_file_bytes > max_total_size {
                    return Err(AppError::UploadTooLarge(state.config.max_upload_size_mb));
                }

                track2_file = Some((filename, data.to_vec(), content_type));
            }
            _ => {}
        }
    }

    // Validate required fields
    if artist_name.is_empty() {
        return Err(AppError::Validation("Artist name is required".to_string()));
    }
    if pronouns.is_empty() {
        return Err(AppError::Validation("Pronouns are required".to_string()));
    }
    if track1_name.is_empty() {
        return Err(AppError::Validation("Track 1 name is required".to_string()));
    }
    if track2_name.is_empty() {
        return Err(AppError::Validation("Track 2 name is required".to_string()));
    }
    if artist_pic_original.is_none() {
        return Err(AppError::Validation(
            "Artist picture is required".to_string(),
        ));
    }
    if track1_file.is_none() {
        return Err(AppError::Validation("Track 1 file is required".to_string()));
    }
    if track2_file.is_none() {
        return Err(AppError::Validation("Track 2 file is required".to_string()));
    }

    // Insert artist record
    let result = sqlx::query(
        r#"
        INSERT INTO artists (
            name, pronouns, track1_name, track2_name, no_voice_message,
            instagram, soundcloud, bandcamp, spotify, other_social,
            upcoming_events, mentions, status
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, 'unassigned')
        "#,
    )
    .bind(&artist_name)
    .bind(&pronouns)
    .bind(&track1_name)
    .bind(&track2_name)
    .bind(no_voice_message)
    .bind(&instagram)
    .bind(&soundcloud)
    .bind(&bandcamp)
    .bind(&spotify)
    .bind(&other_social)
    .bind(&upcoming_events)
    .bind(&mentions)
    .execute(&state.db)
    .await?;

    let artist_id = result.last_insert_rowid();

    // Upload files to R2
    let (pic_filename, pic_data, pic_content_type) = artist_pic_original.unwrap();

    let pic_key = storage::upload_file(
        &state,
        artist_id,
        "pic",
        &pic_filename,
        pic_data.clone(),
        &pic_content_type,
    )
    .await?;

    // Cropped+filtered (no overlay). If not provided, fall back to a simple center-crop.
    let (pic_cropped_filename, pic_cropped_data, pic_cropped_content_type) =
        if let Some((f, d, ct)) = artist_pic_cropped {
            (f, d, ct)
        } else {
            let cropped = crop_square_image_if_supported(&pic_filename, &pic_data)
                .unwrap_or_else(|| pic_data.clone());
            (pic_filename.clone(), cropped, pic_content_type.clone())
        };

    let pic_cropped_key = storage::upload_file(
        &state,
        artist_id,
        "pic_cropped",
        &pic_cropped_filename,
        pic_cropped_data.clone(),
        &pic_cropped_content_type,
    )
    .await?;

    // Branded (cropped+filtered+overlay). If not provided, fall back to the cropped image.
    let (pic_overlay_filename, pic_overlay_data, pic_overlay_content_type) =
        if let Some((f, d, ct)) = artist_pic_branded {
            (f, d, ct)
        } else {
            (
                pic_cropped_filename.clone(),
                pic_cropped_data.clone(),
                pic_cropped_content_type.clone(),
            )
        };

    let pic_overlay_key = storage::upload_file(
        &state,
        artist_id,
        "pic_overlay",
        &pic_overlay_filename,
        pic_overlay_data,
        &pic_overlay_content_type,
    )
    .await?;

    let (track1_filename, track1_data, track1_content_type) = track1_file.unwrap();
    let track1_desired_name = format!("{} - {}", artist_name.trim(), track1_name.trim());
    let track1_key = storage::upload_file_named(
        &state,
        artist_id,
        "track1",
        &track1_desired_name,
        &track1_filename,
        track1_data,
        &track1_content_type,
    )
    .await?;

    let (track2_filename, track2_data, track2_content_type) = track2_file.unwrap();
    let track2_desired_name = format!("{} - {}", artist_name.trim(), track2_name.trim());
    let track2_key = storage::upload_file_named(
        &state,
        artist_id,
        "track2",
        &track2_desired_name,
        &track2_filename,
        track2_data,
        &track2_content_type,
    )
    .await?;

    let voice_key = if let Some((filename, data, content_type)) = voice_message {
        let voice_desired_name = format!("{} - voice-message", artist_name.trim());
        Some(
            storage::upload_file_named(
                &state,
                artist_id,
                "voice",
                &voice_desired_name,
                &filename,
                data,
                &content_type,
            )
            .await?,
        )
    } else {
        None
    };

    // Update artist with file keys
    sqlx::query(
        r#"
        UPDATE artists SET
            pic_key = ?,
            pic_cropped_key = ?,
            pic_overlay_key = ?,
            track1_key = ?,
            track2_key = ?,
            voice_message_key = ?
        WHERE id = ?
        "#,
    )
    .bind(&pic_key)
    .bind(&pic_cropped_key)
    .bind(&pic_overlay_key)
    .bind(&track1_key)
    .bind(&track2_key)
    .bind(&voice_key)
    .bind(artist_id)
    .execute(&state.db)
    .await?;

    Ok(Json(SubmitResponse {
        success: true,
        message: "Thank you for your submission! We'll be in touch soon.".to_string(),
        artist_id: Some(artist_id),
    }))
}
