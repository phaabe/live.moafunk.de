<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stream - Moafunk Admin</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Courier New', Courier, monospace;
            background: #000;
            color: #eee;
            min-height: 100vh;
        }
        
        .nav {
            background: #000;
            padding: 15px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #ffec44;
        }

        .brand {
            display: flex;
            align-items: center;
            gap: 10px;
            min-width: 0;
        }

        .brand-logo {
            width: 26px;
            height: 26px;
            object-fit: contain;
            flex: 0 0 auto;
        }
        
        .nav h1 {
            font-size: 1.4em;
        }
        
        .nav-links {
            display: flex;
            gap: 20px;
            align-items: center;
        }
        
        .nav-links a {
            color: #aaa;
            text-decoration: none;
            transition: color 0.3s;
        }
        
        .nav-links a:hover,
        .nav-links a.active {
            color: #ffec44;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 30px;
        }

        .stream-panel {
            background: #0f0f23;
            border-radius: 8px;
            padding: 40px;
            margin-top: 40px;
        }

        .stream-panel h2 {
            color: #ffec44;
            margin-bottom: 30px;
            font-size: 1.8em;
            text-align: center;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            margin-bottom: 30px;
            padding: 15px;
            background: #1a1a2e;
            border-radius: 6px;
        }

        .status-dot {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        .status-dot.disconnected { background: #666; animation: none; }
        .status-dot.connecting { background: #ffec44; }
        .status-dot.live { background: #22c55e; }
        .status-dot.error { background: #ef4444; animation: none; }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .status-text {
            font-size: 1.1em;
            font-weight: bold;
        }

        .current-streamer {
            text-align: center;
            margin-bottom: 20px;
            color: #888;
        }

        .current-streamer strong {
            color: #ffec44;
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
        }

        .btn {
            padding: 15px 40px;
            font-size: 1.1em;
            font-family: inherit;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
            min-width: 200px;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-primary {
            background: #ffec44;
            color: #000;
        }

        .btn-primary:hover:not(:disabled) {
            background: #fff;
        }

        .btn-danger {
            background: #ef4444;
            color: #fff;
        }

        .btn-danger:hover:not(:disabled) {
            background: #dc2626;
        }

        .btn-secondary {
            background: #333;
            color: #fff;
        }

        .btn-secondary:hover:not(:disabled) {
            background: #444;
        }

        .info-text {
            color: #888;
            font-size: 0.9em;
            text-align: center;
            margin-top: 20px;
            line-height: 1.6;
        }

        .error-message {
            background: #3b1818;
            color: #ef4444;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
            text-align: center;
            display: none;
        }

        .user-info {
            color: #666;
            font-size: 0.85em;
        }

        /* Modal styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal {
            background: #1a1a2e;
            padding: 30px;
            border-radius: 8px;
            max-width: 400px;
            text-align: center;
        }

        .modal h3 {
            color: #ffec44;
            margin-bottom: 15px;
        }

        .modal p {
            margin-bottom: 25px;
            color: #ccc;
        }

        .modal-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
        }

        .audio-level {
            width: 100%;
            height: 8px;
            background: #1a1a2e;
            border-radius: 4px;
            margin: 20px 0;
            overflow: hidden;
        }

        .audio-level-bar {
            height: 100%;
            background: linear-gradient(90deg, #22c55e, #ffec44, #ef4444);
            width: 0%;
            transition: width 0.1s;
        }

        .audio-source-selector {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .audio-source-selector label {
            color: #888;
        }

        .device-select {
            padding: 10px 15px;
            font-size: 1em;
            font-family: inherit;
            background: #1a1a2e;
            color: #eee;
            border: 1px solid #333;
            border-radius: 6px;
            min-width: 250px;
            cursor: pointer;
        }

        .device-select:focus {
            outline: none;
            border-color: #ffec44;
        }

        .btn-small {
            padding: 10px 15px;
            min-width: auto;
            font-size: 0.9em;
        }

        .info-text a {
            color: #ffec44;
            text-decoration: none;
        }

        .info-text a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <nav class="nav">
        <div class="brand">
            <img src="/assets/brand/moafunk.png" alt="Moafunk" class="brand-logo">
            <h1>Moafunk Admin</h1>
        </div>
        <div class="nav-links">
            <a href="/stream" class="active">Stream</a>
            {% if user_role == "admin" or user_role == "superadmin" %}
            <a href="/artists">Artists</a>
            <a href="/shows">Shows</a>
            <a href="/users">Users</a>
            {% endif %}
            {% if user_role == "admin" or user_role == "superadmin" %}
            <a href="/change-password">Change Password</a>
            {% endif %}
            <a href="/logout">Logout</a>
            <span class="user-info">({{ username }})</span>
        </div>
    </nav>
    
    <div class="container">
        <div class="stream-panel">
            <h2>üéµ Audio Stream</h2>

            <div class="error-message" id="errorMessage"></div>

            <div class="status-indicator">
                <div class="status-dot disconnected" id="statusDot"></div>
                <span class="status-text" id="statusText">Disconnected</span>
            </div>

            <div class="current-streamer" id="currentStreamer" style="display: none;">
                Currently streaming: <strong id="streamerName"></strong>
            </div>

            <div class="audio-level" id="audioLevelContainer" style="display: none;">
                <div class="audio-level-bar" id="audioLevelBar"></div>
            </div>

            <div class="controls">
                <div class="audio-source-selector" id="audioSourceSelector">
                    <label for="audioDeviceSelect">Audio Source:</label>
                    <select id="audioDeviceSelect" class="device-select">
                        <option value="">-- Select audio device --</option>
                    </select>
                    <button class="btn btn-secondary btn-small" onclick="refreshDevices()">üîÑ Refresh</button>
                </div>
                <button class="btn btn-primary" id="btnUseDevice" onclick="useAudioDevice()">
                    üéß Use Selected Device
                </button>
                <button class="btn btn-secondary" id="btnShare" onclick="shareAudio()">
                    üñ•Ô∏è Share Screen Audio (Windows only)
                </button>
                <button class="btn btn-primary" id="btnStart" onclick="startStream()" disabled style="display: none;">
                    ‚ñ∂Ô∏è Start Streaming
                </button>
                <button class="btn btn-danger" id="btnStop" onclick="stopStream()" style="display: none;">
                    ‚èπÔ∏è Stop Streaming
                </button>
                <button class="btn btn-secondary" id="btnTakeover" onclick="confirmTakeover()" style="display: none;">
                    üîÑ Take Over Stream
                </button>
                <button class="btn btn-secondary" id="btnRetry" onclick="retryConnection()" style="display: none;">
                    üîÑ Retry Connection
                </button>
            </div>

            <p class="info-text">
                <strong>macOS users:</strong> Install <a href="https://existential.audio/blackhole/" target="_blank" style="color: #ffec44;">BlackHole</a> 
                to capture system audio. Route your audio through BlackHole, then select it above.<br><br>
                <strong>Windows users:</strong> Click "Share Screen Audio" and check "Share audio" in the dialog.<br><br>
                The audio will be streamed to the Moafunk radio server.
            </p>
        </div>
    </div>

    <!-- Takeover confirmation modal -->
    <div class="modal-overlay" id="takeoverModal">
        <div class="modal">
            <h3>‚ö†Ô∏è Take Over Stream?</h3>
            <p id="takeoverMessage">Another user is currently streaming. Taking over will stop their stream.</p>
            <div class="modal-buttons">
                <button class="btn btn-secondary" onclick="closeTakeoverModal()">Cancel</button>
                <button class="btn btn-danger" onclick="forceStartStream()">Take Over</button>
            </div>
        </div>
    </div>

    <script>
        // State
        let mediaStream = null;
        let mediaRecorder = null;
        let webSocket = null;
        let audioContext = null;
        let analyser = null;
        let reconnectAttempts = 0;
        const MAX_RECONNECT_ATTEMPTS = 3;
        const currentUsername = '{{ username }}';

        // UI elements
        const statusDot = document.getElementById('statusDot');
        const statusText = document.getElementById('statusText');
        const errorMessage = document.getElementById('errorMessage');
        const currentStreamer = document.getElementById('currentStreamer');
        const streamerName = document.getElementById('streamerName');
        const audioLevelContainer = document.getElementById('audioLevelContainer');
        const audioLevelBar = document.getElementById('audioLevelBar');
        const btnShare = document.getElementById('btnShare');
        const btnUseDevice = document.getElementById('btnUseDevice');
        const btnStart = document.getElementById('btnStart');
        const btnStop = document.getElementById('btnStop');
        const btnTakeover = document.getElementById('btnTakeover');
        const btnRetry = document.getElementById('btnRetry');
        const takeoverModal = document.getElementById('takeoverModal');
        const audioDeviceSelect = document.getElementById('audioDeviceSelect');
        const audioSourceSelector = document.getElementById('audioSourceSelector');

        // Initialize: enumerate audio devices
        refreshDevices();

        async function refreshDevices() {
            try {
                // Request permission first (needed to get device labels)
                await navigator.mediaDevices.getUserMedia({ audio: true }).then(stream => {
                    stream.getTracks().forEach(track => track.stop());
                }).catch(() => {});

                const devices = await navigator.mediaDevices.enumerateDevices();
                const audioInputs = devices.filter(d => d.kind === 'audioinput');
                
                audioDeviceSelect.innerHTML = '<option value="">-- Select audio device --</option>';
                audioInputs.forEach(device => {
                    const option = document.createElement('option');
                    option.value = device.deviceId;
                    option.textContent = device.label || `Audio Input ${audioInputs.indexOf(device) + 1}`;
                    audioDeviceSelect.appendChild(option);
                });

                console.log('Found audio devices:', audioInputs.map(d => d.label));
            } catch (e) {
                console.error('Failed to enumerate devices:', e);
                showError('Failed to list audio devices. Please allow microphone access.');
            }
        }

        async function useAudioDevice() {
            hideError();
            const deviceId = audioDeviceSelect.value;
            
            if (!deviceId) {
                showError('Please select an audio device first.');
                return;
            }

            try {
                mediaStream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        deviceId: { exact: deviceId },
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: false,
                        sampleRate: 48000,
                        channelCount: 2
                    }
                });

                // Set up audio level meter
                setupAudioMeter(mediaStream);

                // Update UI
                audioSourceSelector.style.display = 'none';
                btnShare.style.display = 'none';
                btnUseDevice.style.display = 'none';
                btnStart.style.display = 'inline-block';
                btnStart.disabled = false;
                audioLevelContainer.style.display = 'block';
                setStatus('connecting', 'Audio source ready');

            } catch (e) {
                console.error('Failed to get audio device:', e);
                showError('Failed to capture audio: ' + e.message);
            }
        }

        // Check stream status on load
        checkStreamStatus();
        setInterval(checkStreamStatus, 5000);

        async function checkStreamStatus() {
            try {
                const res = await fetch('/api/stream/status');
                const status = await res.json();
                
                if (status.active) {
                    currentStreamer.style.display = 'block';
                    streamerName.textContent = status.user || 'Unknown';
                    
                    if (status.user !== currentUsername && !webSocket) {
                        btnTakeover.style.display = 'inline-block';
                    } else {
                        btnTakeover.style.display = 'none';
                    }
                } else {
                    currentStreamer.style.display = 'none';
                    btnTakeover.style.display = 'none';
                }
            } catch (e) {
                console.error('Failed to check stream status:', e);
            }
        }

        function setStatus(status, text) {
            statusDot.className = 'status-dot ' + status;
            statusText.textContent = text;
        }

        function showError(msg) {
            errorMessage.textContent = msg;
            errorMessage.style.display = 'block';
        }

        function hideError() {
            errorMessage.style.display = 'none';
        }

        async function shareAudio() {
            hideError();
            try {
                // Request screen/window share with audio only
                // Note: Chrome requires video: true for getDisplayMedia, but we'll ignore the video track
                mediaStream = await navigator.mediaDevices.getDisplayMedia({
                    audio: {
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: false,
                        sampleRate: 48000,
                        channelCount: 2
                    },
                    video: true  // Required by browser, but we won't use it
                });

                // Check if audio track exists
                const audioTracks = mediaStream.getAudioTracks();
                if (audioTracks.length === 0) {
                    throw new Error('No audio track selected. Make sure to check "Share audio" in the dialog.');
                }

                // Stop video track immediately - we only want audio
                mediaStream.getVideoTracks().forEach(track => track.stop());

                // Create audio-only stream
                const audioStream = new MediaStream(audioTracks);
                mediaStream = audioStream;

                // Set up audio level meter
                setupAudioMeter(audioStream);

                // Update UI
                btnShare.style.display = 'none';
                btnStart.style.display = 'inline-block';
                btnStart.disabled = false;
                audioLevelContainer.style.display = 'block';
                setStatus('connecting', 'Audio source ready');

            } catch (e) {
                console.error('Failed to share audio:', e);
                if (e.name === 'NotAllowedError') {
                    showError('Permission denied. Please allow screen sharing with audio.');
                } else {
                    showError('Failed to capture audio: ' + e.message);
                }
            }
        }

        function setupAudioMeter(stream) {
            audioContext = new AudioContext();
            analyser = audioContext.createAnalyser();
            const source = audioContext.createMediaStreamSource(stream);
            source.connect(analyser);
            analyser.fftSize = 256;

            const dataArray = new Uint8Array(analyser.frequencyBinCount);

            function updateMeter() {
                if (!analyser) return;
                analyser.getByteFrequencyData(dataArray);
                const average = dataArray.reduce((a, b) => a + b) / dataArray.length;
                const percentage = Math.min(100, (average / 128) * 100);
                audioLevelBar.style.width = percentage + '%';
                requestAnimationFrame(updateMeter);
            }
            updateMeter();
        }

        async function startStream(force = false) {
            hideError();
            reconnectAttempts = 0;
            
            if (!mediaStream) {
                showError('No audio source selected. Click "Share System Audio" first.');
                return;
            }

            setStatus('connecting', 'Connecting...');

            try {
                // Connect WebSocket
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                const wsUrl = `${protocol}//${window.location.host}/ws/stream${force ? '?force=true' : ''}`;
                
                webSocket = new WebSocket(wsUrl);
                webSocket.binaryType = 'arraybuffer';

                webSocket.onopen = () => {
                    console.log('WebSocket connected');
                };

                webSocket.onmessage = (event) => {
                    const msg = event.data;
                    if (msg === 'connected') {
                        setStatus('live', 'Live');
                        btnStart.style.display = 'none';
                        btnStop.style.display = 'inline-block';
                        btnTakeover.style.display = 'none';
                        startRecording();
                        checkStreamStatus();
                    } else if (typeof msg === 'string' && msg.startsWith('error:')) {
                        showError(msg.substring(7));
                        setStatus('error', 'Error');
                    }
                };

                webSocket.onerror = (e) => {
                    console.error('WebSocket error:', e);
                    showError('Connection error');
                    setStatus('error', 'Error');
                };

                webSocket.onclose = (e) => {
                    console.log('WebSocket closed:', e.code, e.reason);
                    stopRecording();
                    
                    // Check if we were streaming and should try to reconnect
                    if (mediaStream && reconnectAttempts < MAX_RECONNECT_ATTEMPTS && e.code !== 1000) {
                        reconnectAttempts++;
                        const delay = Math.pow(2, reconnectAttempts - 1) * 1000;
                        setStatus('connecting', `Reconnecting (${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})...`);
                        setTimeout(() => startStream(force), delay);
                    } else if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {
                        setStatus('error', 'Connection lost');
                        btnStart.style.display = 'none';
                        btnStop.style.display = 'none';
                        btnRetry.style.display = 'inline-block';
                    } else {
                        setStatus('disconnected', 'Disconnected');
                        btnStop.style.display = 'none';
                        if (mediaStream) {
                            btnStart.style.display = 'inline-block';
                        }
                    }
                    checkStreamStatus();
                };

            } catch (e) {
                console.error('Failed to start stream:', e);
                showError('Failed to connect: ' + e.message);
                setStatus('error', 'Error');
            }
        }

        function startRecording() {
            if (!mediaStream || !webSocket) return;

            try {
                // Use WebM/Opus for good quality and compatibility
                const options = {
                    mimeType: 'audio/webm;codecs=opus',
                    audioBitsPerSecond: 192000
                };

                if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                    // Fallback
                    options.mimeType = 'audio/webm';
                }

                mediaRecorder = new MediaRecorder(mediaStream, options);

                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0 && webSocket && webSocket.readyState === WebSocket.OPEN) {
                        event.data.arrayBuffer().then(buffer => {
                            webSocket.send(buffer);
                        });
                    }
                };

                mediaRecorder.onerror = (e) => {
                    console.error('MediaRecorder error:', e);
                    showError('Recording error');
                };

                // Start recording with 250ms chunks for low latency
                mediaRecorder.start(250);
                console.log('Recording started');

            } catch (e) {
                console.error('Failed to start recording:', e);
                showError('Failed to start recording: ' + e.message);
            }
        }

        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
                mediaRecorder = null;
            }
        }

        function stopStream() {
            hideError();
            
            // Send stop command
            if (webSocket && webSocket.readyState === WebSocket.OPEN) {
                webSocket.send('stop');
                webSocket.close(1000, 'User stopped');
            }
            webSocket = null;

            stopRecording();

            // Stop media tracks
            if (mediaStream) {
                mediaStream.getTracks().forEach(track => track.stop());
                mediaStream = null;
            }

            // Clean up audio context
            if (audioContext) {
                audioContext.close();
                audioContext = null;
                analyser = null;
            }

            // Reset UI
            setStatus('disconnected', 'Disconnected');
            audioSourceSelector.style.display = 'flex';
            btnShare.style.display = 'inline-block';
            btnUseDevice.style.display = 'inline-block';
            btnStart.style.display = 'none';
            btnStop.style.display = 'none';
            btnRetry.style.display = 'none';
            audioLevelContainer.style.display = 'none';
            
            checkStreamStatus();
        }

        function confirmTakeover() {
            takeoverModal.classList.add('active');
        }

        function closeTakeoverModal() {
            takeoverModal.classList.remove('active');
        }

        function forceStartStream() {
            closeTakeoverModal();
            if (mediaStream) {
                startStream(true);
            } else {
                // Need to get audio first
                shareAudio().then(() => {
                    btnStart.onclick = () => startStream(true);
                });
            }
        }

        function retryConnection() {
            hideError();
            btnRetry.style.display = 'none';
            reconnectAttempts = 0;
            startStream();
        }

        // Clean up on page unload
        window.addEventListener('beforeunload', () => {
            if (webSocket) {
                webSocket.close(1000, 'Page unload');
            }
        });
    </script>
</body>
</html>
