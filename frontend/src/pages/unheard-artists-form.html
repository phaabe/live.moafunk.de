<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>UNHEARD Artists Form - Moafunk Radio</title>

    <script async defer data-domain="live.moafunk.de" src="https://plausible.moafunk.de/js/plausible.js"></script>
    <link rel="stylesheet" type="text/css" href="/main.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="/pages/unheard-artists-form.css" media="screen" />

    <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
    <link rel="manifest" href="/icons/site.webmanifest">
    <link rel="mask-icon" href="/icons/safari-pinned-tab.svg" color="#333333">
    <link rel="shortcut icon" href="/icons/favicon.ico">
    <meta name="msapplication-TileColor" content="#2b5797">
    <meta name="msapplication-config" href="/icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    
    
</head>
<body>
    <div class="uaf-container">
        <div class="uaf-header">
            <img class="logo" src="/moafunk.png" alt="Moafunk Logo" />
            <h1>UNHEARD Artists Form</h1>
            <p>Submit your music to be featured on UNHEARD</p>
        </div>

        <form class="uaf-form" id="uaf-form" enctype="multipart/form-data">
            <!-- Basic Information Section -->
            <div class="form-section">
                <h2>Basic Information</h2>
                
                <div class="form-group">
                    <script type="module" src="/pages/unheard-artists-form.ts"></script>
        async function updateCroppedBlob() {
            if (!artistPicCropper) return;

            // Hide the HTML overlay so it doesn't get captured
            if (overlayRoot) overlayRoot.style.visibility = 'hidden';

            const canvas = artistPicCropper.getCroppedCanvas({
                width: 1024,
                height: 1024,
                imageSmoothingEnabled: true,
                imageSmoothingQuality: 'high',
            });

            // Show the overlay again
            if (overlayRoot) overlayRoot.style.visibility = 'visible';

            if (!canvas) return;

            // Apply the same image filter as the preview (saturate down, contrast up).
            // Do this before drawing the overlay.
            {
                const ctx = canvas.getContext('2d');
                if (ctx) {
                    const filtered = document.createElement('canvas');
                    filtered.width = canvas.width;
                    filtered.height = canvas.height;
                    const fctx = filtered.getContext('2d');
                    if (fctx) {
                        fctx.filter = 'saturate(0.85) contrast(1.08)';
                        fctx.drawImage(canvas, 0, 0);
                        // Reset filter and copy back.
                        ctx.save();
                        ctx.setTransform(1, 0, 0, 1, 0, 0);
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        ctx.restore();
                        ctx.filter = 'none';
                        ctx.drawImage(filtered, 0, 0);
                    }
                }
            }

            // Save cropped+filtered (no overlay)
            const croppedFilteredBlob = await new Promise((resolve) => {
                canvas.toBlob((b) => resolve(b), 'image/jpeg', 0.92);
            });

            if (croppedFilteredBlob) {
                artistPicCroppedFilteredBlob = croppedFilteredBlob;
            }

            // Draw the overlay onto the canvas
            await drawOverlayOnCanvas(canvas);

            // Save branded (cropped+filtered+overlay)
            const brandedBlob = await new Promise((resolve) => {
                canvas.toBlob((b) => resolve(b), 'image/jpeg', 0.92);
            });

            if (brandedBlob) {
                artistPicBrandedBlob = brandedBlob;
            }
        }

        // Modern image uploader (zoom + drag + set frame)
        artistPicInput.addEventListener('change', function(e) {
            const file = e.target.files[0];
            resetCropUi();
            destroyArtistCropper();

            if (!file) return;

            // Check file size first
            if (file.size > MAX_SINGLE_FILE_SIZE_BYTES) {
                alert(`Artist picture exceeds maximum size of ${MAX_SINGLE_FILE_SIZE_MB}MB`);
                e.target.value = '';
                return;
            }

            artistPicOriginalFilename = file.name || 'artist.jpg';
            artistPicObjectUrl = URL.createObjectURL(file);
            cropperImg.src = artistPicObjectUrl;
            cropperWrapper.style.display = 'block';

            // Wait for image to be ready before creating cropper
            cropperImg.onload = () => {
                if (artistPicCropper) artistPicCropper.destroy();
                artistPicCropper = new Cropper(cropperImg, {
                    aspectRatio: 1,
                    viewMode: 3,
                    dragMode: 'move',
                    // 90% => ~5% padding on each side (exact padding enforced via setCropBoxPadding).
                    autoCropArea: 0.9,
                    background: false,
                    guides: false,
                    center: false,
                    highlight: false,
                    cropBoxMovable: false,
                    cropBoxResizable: false,
                    toggleDragModeOnDblclick: false,
                    responsive: true,
                    zoomOnWheel: true,
                    ready() {
                        attachOverlayToActiveCropArea();
                        requestAnimationFrame(fitOverlayName);
                        requestAnimationFrame(() => setCropBoxPadding(0.05));
                        // Generate initial cropped blob
                        updateCroppedBlob();
                    },
                    cropend() {
                        // Update cropped blob when user finishes dragging
                        updateCroppedBlob();
                    },
                    zoom() {
                        // Update cropped blob when user zooms
                        updateCroppedBlob();
                    },
                });
            };
        });

        zoomInBtn.addEventListener('click', () => {
            if (artistPicCropper) artistPicCropper.zoom(0.1);
        });
        zoomOutBtn.addEventListener('click', () => {
            if (artistPicCropper) artistPicCropper.zoom(-0.1);
        });

        // Add file size validation to other file inputs
        ['track1-file', 'track2-file', 'voice-message'].forEach(id => {
            document.getElementById(id).addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (file && file.size > MAX_SINGLE_FILE_SIZE_BYTES) {
                    alert(`File exceeds maximum size of ${MAX_SINGLE_FILE_SIZE_MB}MB`);
                    e.target.value = '';
                }
            });
        });
    </script>
</body>
</html>
